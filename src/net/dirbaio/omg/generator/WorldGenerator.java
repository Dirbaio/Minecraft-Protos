package net.dirbaio.omg.generator;

import com.mojang.nbt.CompoundTag;
import com.mojang.nbt.NbtIo;
import java.awt.Point;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.logging.Level;
import java.util.logging.Logger;

import net.dirbaio.omg.Chunk;
import net.dirbaio.omg.functions.*;
 
public class WorldGenerator implements Runnable
{
    public int xMin, zMin;
    public int xSize, zSize;
    public File path;
    public int chunkCt;
    public int chunkDone;

    public int chunksToSave;

    public Chunk[][] chunks;
	boolean[][] savedChunks;
	
    public LinkedBlockingQueue[] opQueues;

    int numGenThreads = 4;
    int numPopThreads = 5;
    int numLightThreads = 7;

    ChunkGeneratorThread[] genThreads;
    ChunkPopulatorThread[] popThreads;
    ChunkLighterThread[] lightThreads;
    ChunkOutput out;

    public static final int opCount = 3;

    boolean stop = false;
	
	public FunctionTerrain mainFunc;
    
    public WorldGenerator(String path)
    {
        xMin = -64;
        zMin = -64;
        xSize = 128;
        zSize = 128;
        chunks = new Chunk[xSize][zSize];
        savedChunks = new boolean[xSize][zSize];
        this.path = new File(path);
    }

    private void fillGenQueue(int x, int y, int s)
    {
        if(s == 1)
        {
            if(x < xSize && y < zSize) opQueues[0].add(new Point(x, y));
            return;
        }

        int s2 = s/2;
        fillGenQueue(x+s2, y+s2, s2);
        fillGenQueue(x, y+s2, s2);
        fillGenQueue(x+s2, y, s2);
        fillGenQueue(x, y, s2);
    }

    public void setChunkOutput(ChunkOutput out)
    {
        this.out = out;
    }

    //TODO: Move this outta here
    private void generateLevelDat()
    {
		CompoundTag dataTag = new CompoundTag();
		dataTag.putByte("hardcore", (byte)0);
		dataTag.putByte("mapFeatures", (byte)0);
		dataTag.putByte("raining", (byte)0);
		dataTag.putByte("thundering", (byte)0);
		
		dataTag.putInt("GameType", 1); //0 = Survival, 1 = Creative
		dataTag.putInt("generatorVersion", 1);
		dataTag.putInt("rainTime", 0);
		dataTag.putInt("thunderTime", 0);
		dataTag.putInt("SpawnX", 128);
		dataTag.putInt("SpawnY", 256);
		dataTag.putInt("SpawnZ", 128);
		dataTag.putInt("version", 19133);
		dataTag.putLong("LastPlayed", 0);
		dataTag.putLong("RandomSeed", 0);
		dataTag.putLong("SizeOnDisk", 0);
		dataTag.putLong("Time", 0);
		dataTag.putString("generatorName", "default");
		dataTag.putString("LevelName", "Generated by OMG");
		
        File dataFile = new File(path, "level.dat");
		try {
			CompoundTag root = new CompoundTag();
			root.put("Data", dataTag);

			NbtIo.writeCompressed(root, new FileOutputStream(dataFile));
		} catch (Exception e) {
			e.printStackTrace();
		}
    }

    public synchronized Chunk getChunk(int x, int z)
    {
        if(x < 0 || x >= xSize) return null;
        if(z < 0 || z >= zSize) return null;
/*        if(chunks[x][z] == null)
        {
            System.out.println(x+" "+z);
            System.exit(2);
        }*/
        return chunks[x][z];
    }

    public synchronized void setChunk(int x, int z, Chunk c)
    {
        chunks[x][z] = c;
    }

    public static String base36 = "0123456789abcdefghijklmnopqrstuvwxyz";
    public static String toBase36(int i)
    {
        if(i == 0) return "0";

        int n = i;
        if(n < 0) n = -n;

        String res = "";
        while(n != 0)
        {
            res = base36.charAt(n%36) + res;
            n /= 36;
        }
        if(i < 0)
            return "-"+res;
        else
            return res;
    }


    static public boolean deleteDirectory(File path) {
        if (path.exists()) {
            File[] files = path.listFiles();
            for (int i = 0; i < files.length; i++) {
                if (files[i].isDirectory()) {
                    deleteDirectory(files[i]);
                } else {
                    files[i].delete();
                }
            }
        }
        return (path.delete());
    }

    public void generate() throws IOException
    {
        new Thread(this, "Generator reporting thread").start();
    }
    
    public void run()
    {

        //First setup!
        path.mkdirs();
        generateLevelDat();

        //Create queues.
        opQueues = new LinkedBlockingQueue[opCount];
        for(int i = 0; i < opCount; i++)
            opQueues[i] = new LinkedBlockingQueue();

        //Fill them.
        int max = xSize>zSize?xSize:zSize;
        int p = 1;
        while(p < max) p *= 2;

        fillGenQueue(0, 0, p);

        //Some stats.
        chunkDone = 0;
        chunkCt = xSize*zSize;
        chunksToSave = xSize*zSize;
        
		mainFunc.prepare(xMin*16, zMin*16, xSize*16, zSize*16);
		
        //Now, create all the threads.
        //Each thread grabs a copy of all the modules in Configuration.curr
        genThreads = new ChunkGeneratorThread[numGenThreads];
        for(int i = 0; i < numGenThreads; i++)
        {
            genThreads[i] = new ChunkGeneratorThread(this, i);
            genThreads[i].start();
        }

        popThreads = new ChunkPopulatorThread[numPopThreads];
        for(int i = 0; i < numPopThreads; i++)
        {
            popThreads[i] = new ChunkPopulatorThread(this, i);
            popThreads[i].start();
        }

        lightThreads = new ChunkLighterThread[numLightThreads];
        for(int i = 0; i < numLightThreads; i++)
        {
            lightThreads[i] = new ChunkLighterThread(this, i);
            lightThreads[i].start();
        }

        //Report progress.
        while(!stop)
        {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
            }

            System.out.println((chunkDone*100/chunkCt)+"%");

            boolean done = true;
            for(int i = 0; i < numGenThreads; i++)
                if(genThreads[i].isAlive()) done = false;
            if(done) break;
        }
		
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ex) {
            }

		int ct = 0;
		for(int x = 0; x < xSize; x++)
			for(int z = 0; z < zSize; z++)
				if(chunks[x][z] != null)
					ct++;
		
		System.out.println("Loaded chunks? "+ct);
    }

    //OP MANAGEMENT
    //Returns whether chunk has undergone the op
    boolean isChunkOpDone(int x, int z, int op)
    {
        if(x < 0 || x >= xSize) return true;
        if(z < 0 || z >= zSize) return true;
        if(savedChunks[x][z]) return true;
        if(chunks[x][z] == null) return false;

        return chunks[x][z].opsDone[op];
    }

    //Return whether all chunks around have undergone the op
    boolean canDoOpToChunk(int x, int z, int op)
    {
        if(x < 0 || x >= xSize) return false;
        if(z < 0 || z >= zSize) return false;
        if(chunks[x][z] == null) return false;
        if(chunks[x][z].opsDone[op]) return false;
        
        for(int xx = x-2; xx <= x+2; xx++)
            for(int zz = z-2; zz <= z+2; zz++)
                if(!isChunkOpDone(xx, zz, op-1)) return false;

        return true;
    }

    public void setChunkOpDone(int x, int z, int op)
    {
        chunks[x][z].opsDone[op] = true;
        
        for(int xx = x-2; xx <= x+2; xx++)
            for(int zz = z-2; zz <= z+2; zz++)
                if(canDoOpToChunk(xx, zz, op+1))
                    scheduleChunkForOp(xx, zz, op+1);
    }

    public void scheduleChunkForOp(int x, int z, int op)
    {
        if(op > opCount)
			chunks[x][z] = null; //Unload chunk
		else if(op == opCount)
            saveChunk(x, z);
        else
            opQueues[op].add(new Point(x, z));
    }

    public void saveChunk(int xc, int zc)
    {
        chunks[xc][zc].opsDone[3] = true;
        
        chunksToSave--;
        if(chunksToSave == 0)
            stop = true;
        
//		System.out.println("CTS "+chunksToSave);
        Chunk c = getChunk(xc, zc);
        if(out != null)
            out.chunkDone(c);
        else
        {
            try {
                c.writeTo(path);
            } catch (IOException ex) {
                Logger.getLogger(WorldGenerator.class.getName()).log(Level.SEVERE, null, ex);
            }

            chunks[xc][zc] = null;
			savedChunks[xc][zc] = true;
        }
//		setChunkOpDone(xc, zc, 3);
    }
    
    public Chunk[][] createAndLockContext(int x, int z)
    {
        Chunk[][] context = new Chunk[3][3];

        for(int xx = 0; xx < 3; xx++)
            for(int zz = 0; zz < 3; zz++)
            {
                context[xx][zz] = getChunk(x+xx-1, z+zz-1);
                if(context[xx][zz] != null)
                    context[xx][zz].opLock.lock();
            }

        return context;
    }

    public void unlockContext(int x, int z)
    {
        for(int xx = 0; xx < 3; xx++)
            for(int zz = 0; zz < 3; zz++)
            {
                Chunk c = getChunk(x+xx-1, z+zz-1);
                if(c != null)
                    c.opLock.unlock();
            }        
    }
    public void generatedChunk(Chunk c, int xc, int zc)
    {
        if(chunks[xc][zc] != null)
            throw new RuntimeException("Oh, shit!");
        
        setChunk(xc, zc, c);
        setChunkOpDone(xc, zc, 0);

        chunkDone++;
    }

    public void stop()
    {
        stop = true;
    }
}
